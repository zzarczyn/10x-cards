<conversation_summary>
<decisions>
1. **Główna encja**: Tabela `flashcards` będzie głównym miejscem przechowywania danych, powiązanym z `auth.users` poprzez `user_id` (UUID).
2. **Struktura**: Przyjęto płaską strukturę danych – brak obsługi talii (decków) czy kategorii w MVP.
3. **Typy danych treści**: Treść fiszek ograniczona do `VARCHAR(200)` dla przodu i `VARCHAR(500)` dla tyłu, bez możliwości wartości NULL.
4. **Metadane pochodzenia**: Wprowadzenie typu ENUM `card_source_type` (`ai-full`, `ai-edited`, `manual`) do oznaczania źródła fiszki.
5. **Logowanie generacji**: Utworzenie dodatkowej tabeli `generations` do celów analitycznych (czas, model, liczba fiszek).
6. **Relacje**: `flashcards` powiązane z `generations` relacją opcjonalną (nullable `generation_id`) z zasadą `ON DELETE SET NULL`.
7. **Brak wersji roboczych**: Kandydaci na fiszki (drafty) istnieją tylko w pamięci przeglądarki, nie w bazie.
8. **Strategia usuwania**: Zastosowanie trwałego usuwania rekordów (Hard Delete) zamiast Soft Delete.
9. **Klucze główne**: Użycie UUID z `gen_random_uuid()` dla wszystkich kluczy głównych.
10. **Automatyzacja**: Wykorzystanie triggera `moddatetime` do aktualizacji pola `updated_at`.
</decisions>

<matched_recommendations>
1. Wykorzystanie tabeli `auth.users` z Supabase jako jedynego źródła tożsamości (brak osobnej tabeli `profiles`).
2. Implementacja ścisłego Row Level Security (RLS) wymuszającego zgodność `auth.uid() = user_id` dla obu tabel.
3. Utworzenie indeksu złożonego `(user_id, created_at DESC)` dla optymalizacji paginacji.
4. Zastosowanie natywnego typu ENUM zamiast ograniczeń tekstowych `CHECK`.
5. Użycie konkretnych typów `VARCHAR` zamiast ogólnego `TEXT` dla lepszej definicji schematu.
6. Oddzielenie logiki generowania (tabela `generations`) od samej treści, aby nie przechowywać tekstu źródłowego w głównej tabeli.
</matched_recommendations>

<database_planning_summary>
Zaplanowany schemat bazy danych dla MVP 10xCards opiera się na dwóch tabelach w schema `public`: `flashcards` oraz `generations`, ściśle zintegrowanych z systemem uwierzytelniania Supabase (`auth`).

**1. Kluczowe Encje i Atrybuty:**
*   **`flashcards`**: Przechowuje właściwe fiszki.
    *   Kolumny: `id` (UUID), `user_id` (UUID), `front` (VARCHAR 200), `back` (VARCHAR 500), `source` (ENUM), `generation_id` (UUID, nullable), `created_at`, `updated_at`.
*   **`generations`**: Przechowuje historię użycia AI.
    *   Kolumny: `id` (UUID), `user_id` (UUID), `duration_ms` (INT), `card_count` (INT), `model_name` (VARCHAR 100), `created_at`.

**2. Relacje:**
*   `auth.users` -> `flashcards` (1:N): Kaskadowe usuwanie fiszek po usunięciu użytkownika.
*   `auth.users` -> `generations` (1:N): Kaskadowe usuwanie historii po usunięciu użytkownika.
*   `generations` -> `flashcards` (1:N, opcjonalna): Jeśli log generacji zostanie usunięty, pole `generation_id` w fiszce przyjmie wartość NULL (zachowanie treści).

**3. Bezpieczeństwo i Wydajność:**
*   **RLS**: Pełna izolacja danych. Użytkownik ma dostęp CRUD tylko do rekordów, gdzie `user_id` jest zgodne z jego UID sesji.
*   **Indeksowanie**: Kluczowy indeks `(user_id, created_at DESC)` zapewni szybkie ładowanie listy fiszek ("Moja kolekcja") przy rosnącej liczbie rekordów.

**4. Funkcje specyficzne dla PostgreSQL:**
*   Rozszerzenie `moddatetime` dla automatyzacji timestampów.
*   Funkcja `gen_random_uuid()` dla generowania kluczy.
</database_planning_summary>

<unresolved_issues>
Brak zidentyfikowanych otwartych kwestii. Zebrane informacje są kompletne i wystarczające do wygenerowania pełnego pliku migracji SQL (Schema, RLS, Triggers, Indexes) dla PostgreSQL w środowisku Supabase.
</unresolved_issues>
</conversation_summary>
